#!/usr/bin/ruby

require 'fileutils'

# Check if a workload name is provided
if ARGV.empty?
  puts "Usage: workload.template <workload_name>"
  exit 0
end

hook = ARGV[0].downcase
confdir = "../workloads"
srcdir = "../sources/hooks/#{hook}"

# Create workload configuration template
FileUtils.touch("#{confdir}/#{hook}.rb")

# Create directories for integration hook
FileUtils.mkdir_p("#{srcdir}/misc")
FileUtils.touch("#{srcdir}/launch.rb")
FileUtils.touch("#{srcdir}/output_parameters.rb")
FileUtils.touch("#{srcdir}/config.rb")
FileUtils.touch("#{srcdir}/#{hook}.rb")
FileUtils.touch("#{srcdir}/input_parameters.rb")

# populate class definition
class_definition = <<~CLASS
class #{hook.capitalize} < Collector

  def initialize(config, url, mode, logger, series, target)
    super(config, url, mode, logger, series, target)
  end

  require_relative 'launch'

end
CLASS
File.write("#{srcdir}/#{hook}.rb", class_definition)

# populate definition of config parameters
config = <<~CONFIG
class #{hook.capitalize}config < GenericConfig

  def initialize(conf_file)
    @parameters = startup_parameters
    @parameters << iterate_parameters
    load_conf(conf_file)
  end

def startup_parameters
  { }
end

def iterate_parameters
  { }
end

  require_relative 'input_parameters'
  include Parameters

end
CONFIG
File.write("#{srcdir}/config.rb", config)

workload = <<~WORKLOAD
### PROJECT: what project this benchmark is a part of
$project_description = "Testing workload integration"
$project_code = "test"
$project_tier = "test"

### SERIES: identification of this benchmark series
# NOTE: this one must correspond to the directory name of the hook and its classes
$series_benchmark = "example"
$series_description = '#\{$startup_actor\} on #\{$startup_target\} on #\{mode\} #\{shape\}'
$series_owner_name = "John Doe"
$series_owner_email = "john.doe@acme.com"

# STARTUP: how to create the workload?
$startup_actor = "sleep" # No external actor needed, we'll run from within the hook
$startup_target = "file:///etc/hosts" # protocols: file, device, http, object, bucket, ram

# ITERATE: what parameters to benchmark? These parameters form the parameter namespace as a Cartesian
$iterate_iterations = 4 # MODIFY ME
$iterate_schedulers = "none, bfq, kyber, mq-deadline"

# INFRASTRUCTURE
$infra_hosts = "127.0.0.1" # ADDME: benchmark hosts
# User for passwordless ssh to the benchmark nodes
$infra_user = "opc" # user for passwordless SSH to the benchmark nodes
$infra_platform = "oci" # which infrastructure platform we're running on, allowed values: "oci" (TODO: "azure", "aws", "gcp", "nvidia", "misc")
WORKLOAD
File.write("#{confdir}/#{hook}.rb", workload)

output = <<~OUTPUT
# ADD ME: here, define everything that goes to database, in addition to default data
# For instance, OUTPUT_PARAMETERS= "add column collect_inference_time double(20,16) not null, add column iterate_processes int not null"
OUTPUT_PARAMETERS = "
"
OUTPUT
File.write("#{srcdir}/output_parameters.rb", output)

# populate launch script
File.write("#{srcdir}/launch.rb", "class #{hook.capitalize} < Collector")
launch = <<~'LAUNCH'

def launch(config)

require 'open3'
require 'mysql2'

def cartesian(dimensions)
  # Ensure all dimensions are arrays
  normalized_dimensions = dimensions.map do |dim|
    dim.is_a?(Enumerable) ? dim.to_a : [dim]
  end

  # Remove empty dimensions
  filtered_dimensions = normalized_dimensions.reject(&:empty?)

  # Handle special case: single dimension
  if filtered_dimensions.size == 1
    return filtered_dimensions.first.to_enum unless block_given?
    return filtered_dimensions.first.each { |e| yield(e) }
  end

  # Handle multiple dimensions
  cartesian = filtered_dimensions.inject(&:product).map(&:flatten)

  # Return an enumerator if no block is given
  return cartesian.to_enum unless block_given?

  # Yield each combination if a block is given
  cartesian.each do |combination|
    yield(*combination)
  end
end

def push!(query, config)
  mysql = Mysql2::Client.new(default_file: '~/.my.cnf')
  # consumption_cpu = '#{cpu_consumption}',
  # consumption_storage_tps = '#{storage_tps}',
  generic_query = <<-SQL
      insert into #{config[:series_benchmark]} set
      project_description = '\"#{config[:project_description]}\"',
      project_code = '\"#{config[:project_code]}\"',
      project_tier = '\"#{config[:project_tier]}\"',
      series_id = '#{config[:series]}',
      series_description = '\"#{config[:series_description]}\"',
      series_benchmark = '#{config[:series_benchmark]}',
      series_owner_name = '#{config[:series_owner_name]}',
      series_owner_email = '#{config[:series_owner_email]}',
      startup_actor = '#{config[:startup_actor]}',
      infra_host = '#{config[:host]}',
      infra_shape = '#{config[:shape]}',
      infra_filesystem = '\"#{config[:filesystem]}\"',
      infra_storage = '\"#{config[:storage_type]}\"',
      infra_device = '\"#{config[:device]}\"',
      infra_drives = '#{config[:raid_members_amount]}',
      infra_architecture = '\"#{config[:arch]}\"',
      infra_os = '\"#{config[:release]}\"',
      infra_kernel = '\"#{config[:kernel]}\"',
      infra_cpu = '\"#{config[:cpu]}\"',
      infra_cores = '#{config[:cores]}',
      infra_ram = '#{config[:ram]}',
  SQL
  mysql.query(generic_query << query << ";")
end

# CUSTOMIZE: add your "collect" and "iterate" parameters in query
def push(config, collect, iterate, startup)
  query = <<-SQL
      collect_inference_time = '#{collect[:inference_time]}',
      collect_failed_requests = '#{collect[:failed_requests]}',
      collect_cuda_error = '\"#{collect[:cuda_error]}\"',
      collect_response_error = '\"#{collect[:response_error]}\"',
      iterate_iteration = '#{iterate[:iteration]}',
      iterate_processes = '#{iterate[:processes]}',
      iterate_requests = '#{iterate[:requests]}',
      startup_command = '\"#{startup[:command]}\"',
      startup_language = '\"#{startup[:language]}\"'
  SQL
  push!(query, config)
end

  total_invocations = config[:parameter_space_size]
  target = config[:startup_target]
  actor = config[:startup_actor]

  # CUSTOMIZE: add the modules required for your hook
  #require 'oci'
  #require 'pathname'

  # CUSTOMIZE: add initialization of the variables relevant to your target
  language = "bash"
#  app = config[:startup_target_application]
#  app = app.end_with?('.py') ? app.chomp('.py') : app
#  app_dir = File.dirname(app)
#  app_name = File.basename(app)

  # CUSTOMIZE: add your dimensions here in the form config[:my_option].to_a
  dimensions = [
    (1..config[:iterate_iterations]).to_a
# ,
#    config[:iterate_processes].to_a,
#    config[:iterate_requests].to_a
  ]

  # CUSTOMIZE: add your iterator names
  cartesian(dimensions).each do |iteration|

    # CUSTOMIZE: add your semantics of the benchmark invocation

    # execute the benchmark and capture its raw output
    # CUSTOMIZE: build your owb benchmark invokation
    command = "sleep 5 2>&1"
    raw_result = `#{command}`

    # gather everything to push it to the database
    # CUSTOMIZE: extract values from raw_result and any other infrastructure mettrics, if you defined any
    collect = { inference_time: "", failed_requests: "", cuda_error: "", response_error: "" }
    iterate = { iteration: iteration }
    startup = { command: command.gsub("'", "''"), language: language }

    # CUSTOMIZE: when you have prepared collectables, iteratables, and startup values above, uncomment push statement below to push it all to database
    #push(config, collect, iterate, startup)
  end
end

end
LAUNCH
File.open("#{srcdir}/launch.rb", "a") { |file| file.write(launch) }

# template file for workload-specific parameters
parameters = <<~PARAMETERS
module Parameters

# Parameter can be either VNum (for a single numeric value) or VStr (non-numeric values or lists of values)
# Parameters should have data validation, the following validation apply.
#
# For a single numeric parameter:
# VNum.new(natural: true, positive: true, negative: true, range: 1..13, greater: 5, lower: 10)
#
# For multiple values or non-numeric value:
# VStr.new(comma_separated: true, natural: true, non_empty: true, allowed_values: [ "val1", "val2" ])
# 
# You can apply any combination of such validations.

# ADD DEFINITIONS OF WORKLOAD-SPECIFIC STARTUP PARAMETERS
def startup_parameters
  {
    iterate_schedulers: VStr.new(non_empty: true, comma_separated: true, iteratable: true)
  }
end

# ADD YOUR DEFINITIONS OF WORKLOAD-SPECIFIC ITERATABLE PARAMETERS
def iterate_parameters
  {
  }
end

end
PARAMETERS
File.write("#{srcdir}/input_parameters.rb", parameters)

