#!/usr/bin/ruby

require 'fileutils'
require 'open3'
require 'tempfile'
require 'date'
require 'method_source'
require 'mysql2'

require './sources/logger.rb'
require './sources/basic/validation'
require './sources/config/generic_config.rb'
require './sources/config/general_config.rb'
require './sources/distributed/agent.rb'
require './sources/parser.rb'
require './sources/database/database.rb'
require './sources/collector.rb'
require './sources/distributed/transfer.rb'

if false
  require './profiling/profiler.rb'
  class Object
    prepend MethodLogger
  end
end

series = Time.now.to_i.to_s
logger = CustomLogger.new(series)
parser = Parser.new(logger, ARGV)
database = Database.new
config = GeneralConfig.new(parser.conf_file, database.project_codes)
parser.check(config.get(:series_benchmark))

agent = Agent.new(config.get(:infra_user), nil)

# First and foremost, we check and enable (if needed) SSH persistance
# This will maximize the performance of inter-host communication
logger.info("Checking SSH persistance on this host")
`./sources/misc/ssh_sharing.sh`

config.get(:infra_hosts).each do |host|
  logger.info("Checking availability of '#{host}'")
  logger.error("'#{host}' is unavailable, #{agent.error}") if !agent.available?(host)
end

# TODO: this check is benchmark-specific, such checks should perform automatically, as part of config checks
# check if config path exists on the nodes
config.get(:infra_hosts).each do |host|
  logger.info("Checking benchmark executable on '#{host}'")
    logger.error("#{config.get(:startup_executable)} is missing on '#{host}'") if !agent.run(host, :file_exists?, config.get(:startup_executable))
end

# enable all available kernel IO schedulers on the nodes
logger.info("Checking available kernel IO schedulers")
  config.get(:infra_hosts).each do |host|
    %w[mq-deadline kyber bfq none].each do |scheduler|
      `ssh -o StrictHostKeyChecking=no #{config.get(:infra_user)}@#{host} sudo modprobe -q #{scheduler}`
    end
end

logger.info("Checking specification of kernel IO schedulers")
  config.get(:iterate_schedulers).each do |scheduler|
    system_schedulers = `cat /sys/block/sda/queue/scheduler`.strip + " N/A"
    logger.error("unknown IO scheduler '#{scheduler}'") unless system_schedulers.include?(scheduler)
end

unless parser.mode == :space
  config.get(:infra_hosts).each do |host|
    logger.info("Checking if CPU is idle on '#{host}'")
      logger.error("CPU utilization >= 10%, no good for benchmarking") if agent.run(host, :cpu_idle) < 90
    logger.info("Checking if storage is idle on '#{host}'")
      logger.error("IO utilization >= 10%, no good for benchmarking") if agent.run(host,:io_idle) < 90
  end
end

#$hosts.each do |host|
#  $logger.note("benchmark agent on the node '#{host}'") do
#    `scp -q #{generic_launcher} #{local_hook} #{conf_file} #{warning_log.path} #{hook_database} #{$user}@#{host}:/tmp/`
#  end
#end

collector = Hash.new
# depending on benchmark, load a proper config and define its class for the use later
# TODO: this has to be a formuale where class_needed = uppercase variable
#case config.get(:series_benchmark)
#  when "detectron2training" then class_needed = "Detectron2Training"
#  when "dummy" then class_needed = "Dummy"
#  else logger.fatal("unknown benchmark")
#end

class_needed = config.get(:series_benchmark).capitalize

require "./sources/hooks/#{class_needed.downcase}/#{class_needed.downcase}.rb"
require "./sources/hooks/#{class_needed.downcase}/config.rb"

# create benchmark-specific config and merge the general config into it
full_config = Object.const_get("#{class_needed}config").new(parser.conf_file)
full_config.merge(config)

# first phase of description substituion - here we substitute all the variables from the config file
str = full_config.get(:series_description).gsub(/\#\{([^}]+)\}/) do |match|
  v = match[2..-2]
  if full_config.get?(v.to_sym)
    full_config.get(v.to_sym)
  else
    "\#\{" + "#{v}" + "}"
  end
end
full_config.set(:series_description, str)

# TODO: This parameter is benchmark-specific and may not be need for other benchmarks?..
# check if a media the benchmark is going to read from/write to exists on the nodes
full_config.get(:infra_hosts).each do |host|
  logger.info("Checking #{full_config.get(:startup_type)} '#{full_config.get(:startup_media)}' on '#{host}'")
    case full_config.get(:startup_type)
    when "file"
      logger.error("#{full_config.get(:startup_media)} is missing on '#{host}'") if !agent.run(host, :file_exists?, full_config.get(:startup_media))
    when "device"
      logger.error("#{full_config.get(:startup_media)} is missing on '#{host}'") if !agent.run(host, :file_exists?, full_config.get(:startup_media))
    when "bucket"
      logger.error("#{full_config.get(:startup_media)} is missing on '#{host}'") if !agent.run(host, :oci_bucket_exists?, full_config.get(:startup_media))
    when "object"
      logger.error("#{full_config.get(:startup_media)} is missing on '#{host}'") if !agent.run(host, :oci_object_exists?, full_config.get(:startup_media), full_config.get(:sstartup_namespace))
    else
      logger.error("unknown media type '#{full_config.get(:startup_type)}'")
    end
end

# TODO: this should execute in parallel, if explicitly mentioned
# check if filesystem is known on the nodes
full_config.get(:infra_hosts).each do |host|
  logger.error("can't determine filesystem on '#{full_config.get(:startup_media)}'") if !agent.run(host, :get_filesystem, 
full_config.get(:startup_media))
end

# assign collector, aka permanent agent, for each node
# during creation, collector gathers all static data about its infrastructure
mode = full_config.get(:infra_hosts).size > 1 ? "multiple" : "single"
full_config.get(:infra_hosts).each do |host|
  logger.info("Initializing benchmark '#{class_needed.downcase}' on '#{host}'")
  collector[host] = Object.const_get(class_needed).new(full_config, host, mode, logger, series)
end

# create database table for the requested benchmark, if it doesn't exist yet
load "./sources/hooks/#{class_needed.downcase}/schema.rb"
database.table_set(full_config.get(:series_benchmark), SCHEMA)

# Calculate size of the parameter space, and add it to the config for reporting purposes
parameter_space = full_config.iteratable_size
full_config.merge({ iteratable_size: parameter_space })
if parser.mode == :space
  logger.info("parameter space is #{parameter_space} invocations")
  exit 0
end

#TODO: enable scheduler switching in the launcher. The problem is that switching method is out of launcher's method, and doesn't transfer to the remote host automatically.
#TODO: here, we've returned to the current restrictions of the agent functionality: class must respond to value method, and only a single function can transfer.
#TODO: extension is badly required.
#TODO: Also, it's good to get rid of intermediate remote file for storing of the agent's code - how does SSH can directly run a given code with a proper special symbolism?
#TODO: in Collector.initialize, move run! to detach! (and make the detach! truly reenterable)

full_config.get(:infra_hosts).each do |host|
  full_config.merge(collector[host].infra_static)
  logger.info("Launching benchmark '#{class_needed.downcase}' on '#{host}'")
  collector[host].detach(host, :launch, full_config)
# `ssh -o StrictHostKeyChecking=no #{config.get(:infra_user)}@#{host} #{remote_generic_launcher} #{series} #{host} "#{mode}" "#{hook}" "#{remote_conf_file}" #{remote_hook} "#{$schedulers}" #{warning_log.path} #{remote_hook_database} #{log_dir}`
end

logger.info("Benchmark '#{full_config.get(:series_benchmark)}' series #{series} has launched, check logs on '#{full_config.get(:infra_hosts).join(', ')}'")

