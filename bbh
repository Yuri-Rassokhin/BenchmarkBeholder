#!/usr/bin/env ruby

require "bundler/setup"
require 'flex-cartesian'

require './sources/infra/scheduler'
require './sources/infra/platform'
require './sources/infra/utilities_general'
require './sources/options'
require './sources/target'
require './sources/ssh/ssh_sharing'
require './sources/config'
require './sources/head'
require './sources/nodes'
require './sources/global-ruby'
require './sources/hook'
require './sources/log'

series = Time.now.to_i.to_s # start counting total processing time

logger = Log.new # logger for the entire application

logger.info "Starting series #{series}"

options = Options.new(logger, ARGV) # parse CLI options
config = Config.new(logger, options.workload) # parse the workload configuration file
config[:parameters][:host] = options.hosts # add benchmark nodes from CLI
config[:parameters][:series] = series # add unique series ID

Head.check(logger, config) # head node checks such as consistent hook files
Nodes.check(logger, config) # benchmark node checks such as SSH availability, actor presence, etc

# TODO: encapsulate this 
if File.exist?("./sources/hooks/#{config.hook}/prepare.rb")
  require "./sources/hooks/#{config.hook}/prepare"
  logger.info "Running preparations on the nodes"
  config.hosts.each { |h| Global.run(binding, h, Prepare.method(:prepare), logger, config) }
end

target = Target.new(logger, config)

# create the class that implements target metrics using its child named after the hook
require_relative "./sources/hooks/#{config.hook}/metrics"
space = Hook.new(logger, config, target)

logger.info "Parameter space: #{space.dimensions(separator: ', ')}"
logger.info "Number of invocations: #{space.size}"
exit 0 if options.mode == "space"

#  Global.run(binding, h, space.method(:func), :run)

space.func(:run)
logger.info "Series #{series} completed"

report = "./log/bbh-#{config.hook}-#{series}-result.csv"
FileUtils.mkdir_p(File.dirname(report))
space.output(format: :csv, file: report)
space.output(colorize: true, align: true)

