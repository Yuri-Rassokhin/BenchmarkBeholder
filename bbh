#!/usr/bin/ruby

require 'fileutils'
require 'open3'
require 'tempfile'
require 'date'
require 'method_source'
require 'mysql2'

require './sources/logger.rb'
require './sources/basic/validation'
require './sources/config/generic_config.rb'
require './sources/config/general_config.rb'
require './sources/distributed/agent.rb'
require './sources/parser.rb'
require './sources/database/database.rb'
require './sources/collector.rb'
require './sources/distributed/transfer.rb'
require './sources/approach/target.rb'

if false
  require './profiling/profiler.rb'
  class Object
    prepend MethodLogger
  end
end

series = Time.now.to_i.to_s
logger = CustomLogger.new(series)
parser = Parser.new(logger, ARGV)
database = Database.new(logger)
config = GeneralConfig.new(parser.conf_file, database.project_codes)

hook = config.get(:series_benchmark)
hosts = config.get(:infra_hosts)

parser.check(hook)

agent = Agent.new(config.get(:infra_user), nil)

# First and foremost, we check and enable (if needed) SSH persistance
# This will maximize the performance of inter-host communication
logger.info("Checking SSH persistance on the central node")
`./sources/misc/ssh_sharing.sh`

hosts.each do |host|
  logger.info("Checking SSH availability of benchmark node '#{host}'")
  logger.error("#{agent.error}") if !agent.available?(host)
end

# TODO: this check is benchmark-specific, such checks should perform automatically, as part of config checks
# check if config path exists on the nodes
if config.get(:startup_actor) == "self"
  logger.info("Checking actor: 'self' specificed, actor in the hook will be used")
else
  hosts.each do |host|
    logger.info("Checking actor on the benchmark nodes")
    logger.error("actor '#{config.get(:startup_actor)}' is missing on '#{host}'") if !agent.run(host, :file_exists?, config.get(:startup_actor))
  end
end

target = Target.new(agent, logger, config.get(:startup_target))

logger.info("Checking target '#{target.protocol}://#{target.path}'")
hosts.each { |host| target.check(host) }

unless parser.mode == :space
  hosts.each do |host|
    logger.info("Checking if CPU is idle on '#{host}'")
      logger.error("CPU utilization >= 10%, no good for benchmarking") if agent.run(host, :cpu_idle) < 90
    logger.info("Checking if storage is idle on '#{host}'")
      logger.error("IO utilization >= 10%, no good for benchmarking") if agent.run(host,:io_idle) < 90
  end
end

config.delayed_init

# first phase of description substituion - here we substitute all the variables from the config file
config.description_substitute

config.set(:startup_target, target.path)

# collector is a permanent agent assigned to each node to store its infrastructure information and perform actions on it
collector = Hash.new
mode = hosts.size > 1 ? "multiple" : "single"
hosts.each do |host|
  logger.info("Initializing workload '#{hook}' on '#{host}'")
  collector[host] = Collector.new(config, host, mode, logger, series, target)
end

# create database table for the requested benchmark, if it doesn't exist yet
load "./sources/hooks/#{class_needed.downcase}/output_parameters.rb"
database.table_set(hook), OUTPUT_PARAMETERS)

if target.io_schedulers_apply?

  database.table_add_io_schedulers if target.io_schedulers_apply?

  # enable all available kernel IO schedulers on the nodes
  logger.info("Checking available kernel IO schedulers")
  hosts.each do |host|
    %w[mq-deadline kyber bfq none].each do |scheduler|
      `ssh -o StrictHostKeyChecking=no #{config.get(:infra_user)}@#{host} sudo modprobe -q #{scheduler}`
    end
  end

  logger.info("Checking specification of kernel IO schedulers")
    config.get(:iterate_schedulers).each do |scheduler|
      system_schedulers = `cat /sys/block/sda/queue/scheduler`.strip + " N/A"
      logger.error("unknown IO scheduler '#{scheduler}'") unless system_schedulers.include?(scheduler)
  end
end

# Calculate size of the parameter space, and add it to the config for reporting purposes
parameter_space_size = config.parameter_space_size
config.merge({ parameter_space_size: parameter_space_size })
if parser.mode == :space
  logger.info("parameter space size is #{parameter_space_size} invocations")
  config.parameter_space_dimensions
  exit 0
end

#TODO: here, we've returned to the current restrictions of the agent functionality: class must respond to value method, and only a single function can transfer.

hosts.each do |host|
  config.merge(collector[host].infra_static)
  logger.info("Launching workload '#{class_needed.downcase}' on '#{host}'")
  collector[host].detach(host, :launch, config)
end

logger.info("Workload '#{hook}' series #{series} has launched on '#{hosts.join(', ')}'")

